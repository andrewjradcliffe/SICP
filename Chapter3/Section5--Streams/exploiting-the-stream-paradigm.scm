;; 3.5.3 Exploiting the Stream Paradigm

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))

(stream-collect-n (pairs integers integers) 10)

;; Ex. 3.64

;; Option 1
(define (stream-limit-1 s tol)
  (let ((x1 (stream-car s))
        (x2 (stream-car (stream-cdr s))))
    (if (< (abs (- x2 x1)) tol)
        x2
        (stream-limit-1 (stream-cdr s) tol))))

;; Option 2
(define (stream-limit-2 s tol)
  (define (iter x1 s)
    (let ((x2 (stream-car s)))
      (if (< (abs (- x2 x1)) tol)
          x2
          (iter x2 (stream-cdr s)))))
  (iter (stream-car s) (stream-cdr s)))

;; completing the exercise
(define (average x y) (/ (+ x y) 2))
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)
(define (sqrt-to-tol x tol)
  (stream-limit-2 (sqrt-stream x) tol))

(sqrt-to-tol 2 .01)

;; Ex. 3.65

;; sequence accelerators
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1))
        (s2 (stream-ref s 2)))
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))

(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))

(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))


;; ln2 = 1 - 1/2 + 1/3 - 1/4 + ...

(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (ln2-summands (+ n 1)))))

;; raw series
(define ln2-stream
  (partial-sums (ln2-summands 1)))

;; single transform
(define ln2-stream-improved
  (euler-transform ln2-stream))

;; recursively transformed
(define ln2-stream-accelerated
  (accelerated-sequence euler-transform ln2-stream))

(stream-ref ln2-stream 3)
(stream-ref ln2-stream-improved 3)
(stream-ref ln2-stream-accelerated 3)

;; Ex. 3.67

(define (pairs-all s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (interleave (stream-map (lambda (x) (list x (stream-car t)))
                            (stream-cdr s))
                (pairs-all (stream-cdr s) (stream-cdr t))))))

(stream-collect-n (pairs-all integers integers) 10)

;; Ex. 3.68
;; Does not work as pairs contains no delayed evaluations, thus, the recursive pairs call
;; will be evaluated on each entry into the pairs body. Therefore, when evaluated on
;; infinite streams, this results in an infinite recursion.

;; Ex. 3.69

(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   ;; ;; This works, but heavily favors the third variable
   ;; (interleave
   ;;  (stream-map (lambda (x) (list (stream-car s) (stream-car t) x))
   ;;              (stream-cdr u))
   ;;  (interleave
   ;;   (triples s (stream-cdr t) (stream-cdr u))
   ;;   (triples (stream-cdr s) (stream-cdr t) (stream-cdr u))))
   ;; ;; An attempt at incrementing the third variable more slowly -- quite effective.
   ;; (interleave
   ;;  (triples (stream-cdr s) (stream-cdr t) (stream-cdr u))
   ;;  (interleave
   ;;   (triples s (stream-cdr t) (stream-cdr u))
   ;;   (stream-map (lambda (x) (list (stream-car s) (stream-car t) x))
   ;;               (stream-cdr u))
   ;;   ))
   ;; Correct version, without duplication
   (interleave
    (stream-map (lambda (pair) (cons (stream-car s) pair))
                (pairs t (stream-cdr u)))
    (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))
   ))

(define (pythagorean-triple? i j k)
  (= (+ (square i) (square j)) (square k)))

(define pythagorean-triples
  (stream-filter
   (lambda (x) (pythagorean-triple? (car x) (cadr x) (caddr x)))
   (triples integers integers integers)))

(stream-ref pythagorean-triples 5)
(stream-collect-n pythagorean-triples 5)

;; Ex. 3.70

(define (weighted-merge weight s1 s2)
  (let ((s1car (stream-car s1))
        (s2car (stream-car s2)))
    (let ((w1 (weight s1car))
          (w2 (weight s2car)))
      (cond ((< w1 w2)
             (cons-stream s1car
                          (weighted-merge weight
                                          (stream-cdr s1)
                                          s2)))
            ((> w1 w2)
             (cons-stream s2car
                          (weighted-merge weight
                                          s1
                                          (stream-cdr s2))))
            ((= w1 w2)
             (cons-stream s1car
                          (weighted-merge weight
                                          (stream-cdr s1)
                                          ;; We do not want to eliminate items
                                          ;; based on equal weights, but rather,
                                          ;; arbitrarily select one to precede the other.
                                          s2)))))))

(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (weighted-merge weight
                   (stream-map (lambda (x) (list (stream-car s) x))
                               (stream-cdr t))
                   (weighted-pairs weight
                                   (stream-cdr s)
                                   (stream-cdr t)))))

;; a
(define (weight-a p) (+ (car p) (cadr p)))

(define result-a
  (weighted-pairs
   weight-a
   integers
   integers))

(stream-collect-n result-a 10)

;; b
(define (weight-b p) (+ (* 2 (car p)) (* 3 (cadr p)) (* 5 (car p) (cadr p))))

(define (divisible-by-2? x) (divisible? x 2))
(define (divisible-by-3? x) (divisible? x 3))
(define (divisible-by-5? x) (divisible? x 5))

(define result-b
  (stream-filter
   (lambda (p) (and (not (divisible-by-2? (car p)))
                    (not (divisible-by-2? (cadr p)))
                    (not (divisible-by-3? (car p)))
                    (not (divisible-by-3? (cadr p)))
                    (not (divisible-by-5? (car p)))
                    (not (divisible-by-5? (cadr p)))))
   (weighted-pairs
    weight-b
    integers
    integers)))


(stream-collect-n result-b 10)
