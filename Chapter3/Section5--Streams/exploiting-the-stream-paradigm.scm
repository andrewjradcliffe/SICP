;; 3.5.3 Exploiting the Stream Paradigm

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


;; Ex. 3.67

(define (pairs-all s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (interleave (stream-map (lambda (x) (list x (stream-car t)))
                            (stream-cdr s))
                (pairs-all (stream-cdr s) (stream-cdr t))))))

(stream-collect-n (pairs-all integers integers) 10)

;; Ex. 3.68
;; Does not work as pairs contains no delayed evaluations, thus, the recursive pairs call
;; will be evaluated on each entry into the pairs body. Therefore, when evaluated on
;; infinite streams, this results in an infinite recursion.

;; Ex. 3.69

(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   ;; This works, but heavily favors the third variable
   ;; (interleave
   ;;  (stream-map (lambda (x) (list (stream-car s) (stream-car t) x))
   ;;              (stream-cdr u))
   ;;  (interleave
   ;;   (triples s (stream-cdr t) (stream-cdr u))
   ;;   (triples (stream-cdr s) (stream-cdr t) (stream-cdr u))))
   ;; An attempt at incrementing the third variable more slowly -- quite effective.
   (interleave
    (triples (stream-cdr s) (stream-cdr t) (stream-cdr u))
    (interleave
     (triples s (stream-cdr t) (stream-cdr u))
     (stream-map (lambda (x) (list (stream-car s) (stream-car t) x))
                 (stream-cdr u))
     ))
   ))

(define (pythagorean-triple? i j k)
  (= (+ (square i) (square j)) (square k)))

(define pythagorean-triples
  (stream-filter
   (lambda (x) (pythagorean-triple? (car x) (cadr x) (caddr x)))
   (triples integers integers integers)))

(stream-ref pythagorean-triples 200)
(stream-collect-n pythagorean-triples 200)

;; Ex. 3.70

(define (weighted-merge weight s1 s2)
  (let ((s1car (stream-car s1))
        (s2car (stream-car s2)))
    (let ((w1 (weight s1car))
          (w2 (weight s2car)))
      (cond ((< w1 w2)
             (cons-stream s1car
                          (weighted-merge weight
                                          (stream-cdr s1)
                                          s2)))
            ((> w1 w2)
             (cons-stream s2car
                          (weighted-merge weight
                                          s1
                                          (stream-cdr s2))))
            ((= w1 w2)
             (cons-stream s1car
                          (weighted-merge weight
                                          (stream-cdr s1)
                                          (stream-cdr s2))))))))

(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (weighted-merge weight
                   (stream-map (lambda (x) (list (stream-car s) x))
                               (stream-cdr t))
                   (weighted-pairs weight
                                   (stream-cdr s)
                                   (stream-cdr t))
                   ;; (weighted-pairs weight
                   ;;                 (stream-cdr s)
                   ;;                 t)
                   ;; (weighted-pairs weight
                   ;;                 s
                   ;;                 (stream-cdr t))
                   )))

;; a
(define (weight p) (+ (car p) (cadr p)))

(define result-a
  (weighted-pairs
   weight
   integers
   integers))

(stream-collect-n result-a 10)
