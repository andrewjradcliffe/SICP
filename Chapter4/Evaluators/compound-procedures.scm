;; Useful compound procedures which, outside edge cases, must be defined in the
;; implemented language (rather than implementation language).

(define (memq x seq)
  (cond ((null? seq) false)
        ((eq? x (car seq)) true)
        (else (memq x (cdr seq)))))
(define (member x seq)
  (cond ((null? seq) false)
        ((equal? x (car seq)) true)
        (else (member x (cdr seq)))))
(define (filter proc items)
  (cond ((null? items) items)
        ((proc (car items))
         (cons (car items)
               (filter proc (cdr items))))
        (else (filter proc (cdr items)))))

;;;; Folds
(define (fold-right op init sequence)
  (if (null? sequence)
      init
      (op (car sequence)
          (fold-right op init (cdr sequence)))))
(define (fold-left op result sequence)
  (if (null? sequence)
      result
      (fold-left op (op result (car sequence)) (cdr sequence))))

(define (reverse sequence)
  (fold-left (lambda (a b) (cons b a)) '() sequence))
;; (define (map proc sequence)
;;   (fold-right (lambda (a b) (cons (proc a) b)) '() sequence))
;; (define (append x y)
;;   (fold-right cons y x))
;; (define (length sequence)
;;   (fold-left (lambda (a b) (+ a 1)) 0 sequence))

(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
(define (map proc seq)
  (if (null? seq)
      '()
      (cons (proc (car seq))
            (map proc (cdr seq)))))
(define (for-each proc seq)
  (if (null? seq)
      'done
      (begin (proc (car seq))
             (for-each proc (cdr seq)))))
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

;;;; List-related
(define (list-ref seq i)
  (if (= i 0)
      (car seq)
      (list-ref (cdr seq) (- i 1))))

(define (length seq)
  (define (iter n s)
    (if (null? s)
        n
        (iter (+ n 1) (cdr s))))
  (iter 0 seq))

;;;; Miscellaneous
(define (enumerate-interval start end)
  (define (iter current seq)
    (if (< current start)
        seq
        (iter (- current 1) (cons current seq))))
  (iter end '()))

(define (transpose m)
  (accumulate-n cons '() m))

;;;; car and cdr
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caar x) (car (car x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cadar x) (car (cdr (car x))))
(define (cdaar x) (cdr (car (car x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
